# 汇编中的指令

## mov

1. mov 寄存器, 数据
2. mov 寄存器, 寄存器
3. mov 寄存器, 内存单元
4. mov 内存单元, 寄存器
5. mov 段寄存器, 寄存器
6. mov 寄存器, 段寄存器
7. mov 内存单元, 段寄存器
8. mov 段寄存器, 内存单元

## push, pop: 入栈, 出栈

## 汇编中数据位置的表达

1. 立即数, 在汇编指令中直接给出
2. 寄存器: 指令要处理的数据在寄存器中
3. 段地址(SA)和偏移地址(EA)

## 转移指令
可以修改IP, 或者同时修改CS和IP的指令统称为为转移指令.
1. 只修改IP, 称为段内转移, 如jmp ax
    1. 段内转移分为短转移和近转移. 短转移(jmp short xx)IP的修改范围为-128~127, 近转移IP(jmp near xx)的修改范围为-32768~32767
2. 同时修改CS和IP时, 称为段间转移, 如jmp 1000:0(jmp far ptr xx)

### 分类
1. 无条件转移指令(如:jmp)
2. 条件转移指令
3. 循环指令(如: loop)
4. 过程
5. 中断
### 转移类型
1. 转移地址在内存  
   1. jmp word ptr 内存单元地址(段内转移)
   2. jmp dword ptr 内存单元地址(段间转移)
## 操作符

1. db: 分配字节空间
2. dw: 分配字空间
3. dd: 分配双字空间
4. dup: 定义重复内容
5. offset: 取得标号的偏移地址
   
## jcxz指令
jcxz指令为有条件转移指令, 所有的有条件转移指令都是短转移.  
指令格式: jcxz标号(如果(cx)=0, 转移到标号处执行)  
操作: 当(cx) = 0时, (IP) = (IP) + 8位位移

## loop指令
loop指令为循环指令, 所有的循环指令都是短转移.

## ret和retf
1. ret指令用栈中的数据, 修改IP的内容, 从而实现近转移
2. retf指令用栈中的数据, 修改CS和IP的内容, 从而实现远转移.

## call指令
call指令执行时, 进行两步操作: 
1. 将当前的IP或CS和IP压入栈中
2. 转移  
call指令不能实现短转移. call指令实现转移的方法和jmp指令的原理相同.

### 依据位移进行转移的call指令
call 标号

### 转移的目的地址在指令中的call指令
call far ptr 标号

### 转移地址在寄存器中的call指令
call 16位reg

### 转移地址在n内存中的call指令
call dword ptr 内存单元地址

## mul指令
mul是乘法指令. 两个相乘的数, 要么都是8位, 要么都是16位. 如果是8位, 一个默认放在al中, 另一个放在8位reg或内存字节单元中; 如果是16位, 一个默认放在ax中, 另一个放在16位reg或内存单元中.
结果: 如果是8位乘法, 结果默认放在ax中; 如果是16位乘法, 结果高位默认放在dx中, 低位放在ax中.

## adc指令
adc是带进位加法指令, 它利用了CF位上记录的进位值. 用来进行多位加法运算

## cmp指令
cmp是比较命令, cmp的功能相当于减法指令, 只是不保存结果.

## movsb指令(串传送指令)
类似于下面的汇编指令: 
```complier
mov es:[di], byte ptr ds:[si]
df = 0:
inc si
inc di
df = 1:
dec si
dec di
```
## movsw指令
movsw的功能是将ds:si指向的内存字单元中的字送入es:di中, 然后根据标志寄存器df位的值, 将si和di递增2或递减2.
> movsb和movsw进行时串传送操作中的一个步骤, 一般来说, 都和rep配合使用.

## rep指令
```
rep movsb
; 类似于
s: movsb
loop s
```
rep的作用是根据cx的值, 重复执行后面的串传送指令.

## pushf和popf指令
pushf的功能是将标志寄存器的值压栈, 而popf是从栈中弹出数据, 送入标志寄存器中
