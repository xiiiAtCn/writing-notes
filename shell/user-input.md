#### 命令行参数

##### 读取参数
bash会将一些称为位置参数的特殊变量分配给输入到命令行中的所有参数. 这也包括shell所执行的脚本名称. 位置参数变量是标准的数字: $0是程序名, $
1是第一个参数, $2是第二个参数, 一直到第九个参数$9. 如果脚本参数不止9个, 仍然可以处理. 不过要稍微修改一下变量名. 在第9个变量之后, 必须在变量数字周围加上花括号. 比如${10}

##### 读取脚本名
可以用$0参数获取shell在命令行启动的脚本名. 如
```
#!/bin/bash
echo The zero parameter is set to: $0

$
$ bash test5.sh
The zero parameter is set to: test5.sh
```
但这里存在一个潜在的问题. 如果使用另一个命令来运行shell脚本, 命令会和脚本名混在一起, 出现在$0参数中. 当传给$0变量的实际字符串不仅仅是脚本名, 而是完整的脚本路径时, 变量$0就会使用整个路径. 不过basename命令会返回不包含路径的脚本名

##### 测试参数
当脚本认为参数变量中会有数据而实际上并没有时, 脚本很有可能会产生错误消息. 这种写脚本的方法并不可取. 在使用参数之前一定要检查其中是否存在数据

#### 特殊参数变量

##### 参数统计
可以统计一下命令行中输入了多少个参数. 无需测试每个参数. bash shell为此提供了一个特殊变量.  
特殊变量$#含有脚本运行时携带的命令行参数的个数. 可以在脚本中任何地方使用这个特殊变量. 可以通过这个变量获取命令行最后一个参数, ${!#}

##### 抓取所有的数据
$*和$@变量可以用来访问所有的参数. 这两个变量都能够在单个变量中存储所有的命令行参数. $\*变量会将命令行上提供的所有参数当作一个单词保存. 这个单词包含了命令行中出现的每一个参数值. $@变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词. 这样就能够遍历所有的参数值.

#### 移动变量
bash中的shift命令能够用来操作命令行参数. shift命令会根据它们的相对位置来移动命令行参数.   
在使用shift命令时, 默认情况下它会将每个变量向左移动一个位置. 所以, 变量$3的值会移动$2, $2的值会移动到$1, $1的值则会被删除. $0的值不变
> 使用shift命令之后, 如果某个参数被移出, 它的值就被丢弃了, 无法再回复, $@和$*中也不会保留
也可以一次性移动多个位置, 只需要给shif命令提供一个参数, 指明要移动的位置数.

#### 处理选项
选项是跟在单破折号后面的单个字母

##### 查找选项
1. 处理简单选项  
在提取每个单独参数时, 用case语句来判断某个参数是否为选项
2. 分离参数和选项
shell脚本中同时出现选项和参数时, Linux使用特殊字符来将二者分开. 该字符会告诉脚本何时选项结束以及普通参数何时开始. 对linux来说, 这个特殊字符是双破折号(--). shell会用双破折号来表明列表结束. 在双破折号之后, 脚本就可以将剩下的命令行参数当作参数, 而不是选项来处理.

##### 使用getopt命令
getopt命令是一个在处理命令行选项和参数时非常方便的工具. 它能够识别命令行参数, 从而在脚本中解析它们时更方便
1. 命令格式
getopt命令可以接受一系列任何形式的命令行选项和参数, 并自动将它们转换成适当的格式, 命令格式如下:
```
getopt optstring parameters
```
optstring是这个过程的关键所在. 它定义了命令行有效的选项字母, 还定义了哪些选项字母需要参数值.  
首先, 在optstring中列出要在脚本中用到的每一个命令行选项字母. 然后, 在每个需要参数值的选项字母后加一个冒号. 如果指定了一个不在optstring中的选项, 默认情况下, getopt命令会产生一条错误消息.如果想忽略这条错误消息, 可以在命令后追加-q选项.
2. 在脚本中使用getopt  
方法是用getopt命令生成的格式化后的版本来替换已有的命令行选项和参数. 用set命令能够做到.  
set命令的选项之一是破折号(--), 它会将命令行参数替换成set命令的命令行值
```
set -- $(getopt -q ab:cd "$@")
```
但是, getopt命令并不擅长处理带空格和引号的参数值. 它会将空格当作参数分隔符, 而不是根据双引号将二者当作一个参数

##### 更高级的getopts命令
getopts命令能够和已有的shell参数变量配合默契. 每次调用它时, 它一次只处理命令行上检测到的一个参数. 处理完所有的参数后, 它会退出并返回一个大于0的退出状态码. 这让它非常适合用于解析命令行所有参数的循环中.格式如下:
```
getopts optstring variable
```
有效的选项字母都会列在optstring中, 如果选项字母要求有个参数值, 就加一个冒号. 要去掉错误消息的话, 可以在optstring之前加一个冒号. getopts命令将当前参数保存在命令行定义的variable中.  
getopts命令会用到两个环境变量. 如果选项需要跟一个选项值, OPTARG环境变量就会保存这个值. OPTIND环境变量保存了参数列表中getopts正在处理的参数位置. 
optstring中未定义的选项字母会以问号形式发送给代码

#### 选项标准化
Linux中常用的命令行选项的常用含义

|选项|描述|
|---|---|
|-a|显示所有对象|
|-c|生成一个计数|
|-d|指定一个目录|
|-e|扩展一个对象|
|-f|指定读入数据的文件|
|-h|显示命令的帮助信息|
|-i|忽略文本大小写|
|l|产生输出的长格式版本|
|-n|使用非交互模式(批处理)|
|-o|将所有输出重定向到指定的输出文件|
|-q|以安静模式运行|
|-r|递归地处理目录和文件|
|-s|以安静模式运行|
|-v|生成详细输出|
|-x|排除某个对象|
|-y|对所有问题回答yes|

#### 获得用户输入

##### 基本的读取
read命令从标准输入(键盘)或另一个文件描述符中接受输入. 在收到输入后, read命令将数据放进一个变量. 实际上, read命令包含了-p选项, 允许你直接在read命令行指定提示符. read命令会将提示符后输入的所有数据分配给单个变量, 要么你就指定多个变量. 输入的每个数据值都会分配给变量列表中的下一个变量. 也可以在read命令中不指定变量. 如果是这样, read命令会将它收到的任何数据都放进特殊环境变量REPLY中.
##### 超时
可以使用-t选项来指定一个计时器. -t选项指定了read命令等待输入的秒数. 当计时器过期后, read命令会返回一个非零退出状态码. 也可以不对输入过程计时, 而是让read命令来统计输入的字符数. 当输入的字符达到预设的字符数时, 就自动退出. -n[num]

##### 隐藏方式获取
-s选项可以避免在read命令中输入的数据显示在显示器上.

##### 从文件中读取
可以用read命令来读取Linux系统上文件中保存的数据. 每次调用read命令, 它都会从文件中读取一行文本. 当文件中没有内容时, read命令会退出并返回非零退出状态码